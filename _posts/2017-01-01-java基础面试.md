---
layout: post
title: java基础面试
categories: 面试
tags:  面试
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境



Java基础
1、List 和 Set 的区别
2、HashSet 是如何保证不重复的
3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?
4、HashMap 的扩容过程
5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？
6、final finally finalize
7、强引用 、软引用、 弱引用、虚引用
8、Java反射
9、Arrays.sort 实现原理和 Collection 实现原理
10、LinkedHashMap的应用
11、cloneable接口实现原理
12、异常分类以及处理机制
13、wait和sleep的区别
14、数组在内存中如何分配

69、java 的 array 跟 list的比较，底层原理上的

TreeSet hashSet区别
hashmap如何截图冲突 扩容
https://blog.csdn.net/moakun/article/details/80494253
反射能获得类里面的名称吗。参数名称呢 参数类型
动态代理实现方式  cglib 和jdk代理区别



Synchronized原理

Volate

获取锁 需要通过循环CAS

现状：

 当今编译器和处理器会重排序执行语句，利用CPU的高速缓存，和流行线加大并行度，加快代码执行速度。让我们想想，如果我们只有单核和单线程，所有的代码都是按序执行，肯定不会有任何问题，但是如果加上多核多线程，某一个线程执行写入数据到CPU缓存，没有及时刷新到内存，没有通知其他CPU的本地缓存已经失效，其他线程可能使用这个失效缓存，就会导致不一致的问题。那么JAVA是如何提供多线程下通过共享内存同步信息下的准确性呢？

重排序：

1. 首先争对编译器重排序，我们需要保证编译器在不影响单线程语义下重排序语句。
2. 如果不存在数据依赖(读后写，写后读，写后写)，处理器会改变机器指令的顺序
3. 内存系统的重排序，因为利用了缓存，导致先写后读，可能最后是先读会写，写操作没有及时回写到内存。

其实如果是单线程执行，1，2，3其实都没问题，但是对于多线程就有问题了，2，3的重排序，就会导致内存可见性的问题，起码可以了解成多线程之间的数据依赖，单线程的无数据依赖的重重排序，在全局来说是可能是数据依赖的重排序，就会有问题。那为了保证关键时刻的内存的可见性，既然你内存因为缓存重排序，那我就让你特定未知缓存必须刷新到内存，处理器重排序指令，我也规定你在特定位置不能重排序，java就是通过插入内存屏障(Memory barriers)执行重排序，维持一致的内存可见性。例如StoreLoad Barriers (Store1 Barries Load2)就是确保Store1的数据刷新到内存(对其他处理器可见)优先于Load2以及后续的load指令，另外会使屏障之前的所有内存访问指令(store and load)都在屏障之前执行完。

as-if-serial语义

  就是保证单线程执行在重排序的情况下，执行结果跟没有排序一样，通过禁止处理器和编译器对有数据依赖的操作进行重排序

happen before:

A happen before B, 其实就是想说A的结果对于B可见，其实就是JMM提供给我们程序员的一个简单的抽象，告诉我们什么情况内存可见性满足，例如volatile变量的写，happen before 对后续对这个volatie变量的读； 一个线程的操作都happens before该线程的后续操作，通过这种简单的happens before关系，我们知道什么时候，操作A的结果，会在执行操作B时肯定可见。
jMM为了提供happen before的保证，其实暗地里就是通过上面说的插入内存屏障，强刷内存，导致禁止某些重排序所实现。不过对于A happen before B, 如果B对A的结果并不依赖，JMM是允许这种重排序，不然按照线程操作的happens before每个操作结果对于后续操作可见(即使不依赖)，那样子按序执行，就没有任何优化的地方了。


顺序一致性内存模型：

  一个理想的模型，
  1. 一个线程下所有操作必须按序执行
  2. (不管)程序是否同步，所有线程都看到一个单一的操作执行顺序，每个操作都是原子性并立刻对所有线程可见。
  
  这模型显然很严格，很用于优化，一般来说，如果线程正确同步，得到执行结果跟按照顺序一致性内存模型结果一样，
那么我们就可以称具有顺序一致性。关键在于我们需要同步(不同步，数据就没法刷新到内存)，通过锁，我们保证进入临界区，和出来临界区时，跟顺序一致性内存模型具有一致的内存视图，而且JMM保证临界区内的代码不会重排序到临界区外面


volatile 
volatile变量的写读可以实现线程间通信，在内存语义上，与锁的获取释放一样。

简单理解就是，写一个volatile变量，就要把这跟之前的所有本地缓存刷到主内存中，而读volatile变量，则把线程的本地缓存智为无效，从主内存中国读取变量，这样子就实现了了一次通信，通知变量更新。其实提供volatile就是为了提供一种轻量级的线程间的通信，为了保证有这种内存语义，我们还需要禁止特定的重排序，不然一个普通写跟volatile的写重排序，就没法保证这个普通能及时刷新到内存，如果排在volatile后面，所以我们需要在volatile读写操作上下插入内存屏障，保证部分重排序不能进行。
这样子，在读写volatile这个点上，通过votatile本身特性，强制刷新内存(lock的实现), 来保证happens before.


锁的内存含义

释放锁的时候，把所有本地变量都刷新到内存上，而在获取锁的时候，在监视器保护的临界区代码，会把本地缓存的置为无效，从内存中获取共享变量。





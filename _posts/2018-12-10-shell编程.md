---
layout: post
title: shell编程学习
categories: it
tags:  it 
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境

shell编程学习



# 结构化语句

## if-then 

if判断的是后面command命令的退出状态码，如果是0，则执行then后面的语句


```bash
if command
then
    commands
fi  
if command then
    commands
fi    
```

## if-then-else


```bash
if command
then 
    commands
else
    commands
fi    
```

## 嵌套if

```bash
if command then
    comands
elif command then
    commands
else
    commands
fi    
```

栗子

```bash
#!/bin/bash 
# Testing nested ifs - use elif & else # 
testuser=NoSuchUser # 
if grep $testuser /etc/passwd then
    echo "The user $testuser exists on this system." # 
elif ls -d /home/$testuser then
    echo "The user $testuser does not exist on this system."
    echo "However, $testuser has a directory." # 
else
    echo "The user $testuser does not exist on this system."
    echo "And, $testuser does not have a directory."
fi
```

## test 命令

格式：test condition

```bash
if test condition
then
    commands
fi 
# 方括号定义了测试条件，第一个方括号之后和第二个方括号之前必须加入一个空格
if [ condition ]
then
    commands
fi  
```

### 数值比较

ps. 只处理整数(bash shell只处理整数)
![-w753](../blog_picture/2018-12-10-shell/15444270851502.jpg)

栗子

```bash
if [ $var -gt 10 ] 
then echo "win"
fi
```
### 字符串比较

![-w773](../blog_picture/2018-12-10-shell/15444272428564.jpg)

> 大于号和小于号必须转义，否则会变成重定向符号，字符串值当做文件名
> 大于号和小于号和sort命令(小写在前面test < Test)采用比较标准不一样

> ps. test命令和测试表达式用标准数学符号比较字符串(> != <), 二用文本代码表达数值比较(-eq -ge)
> 空的和未初始化变量会带脚本带来灾难性影响，所以比较之前先用-n和-z测试变量是否有值

## 文件比较

![-w756](../blog_picture/2018-12-10-shell/15444275997268.jpg)

栗子

```bash
if [ -e $file]
```

### 复合条件测试


```command
[ condition1 ] && [ condition2 ]
[ condition1 ] || [ condition2 ]

```

## if-then高级特性

### 双括号数学表达式

```bash
(( expression )) 
# 栗子
if (( $val1 ** 2 > 90 )) then
    (( val2 = $val1 ** 2 ))
    echo "The square of $val1 is $val2" 
fi
```

![-w761](../blog_picture/2018-12-10-shell/15444280358141.jpg)


### 双方括号


```bash
[[ expression ]]
# 模式匹配 正则匹配字符串
if [[ $User == r* ]]
then echo "hello $User"
fi
```

## case命令


```bash
case variable in 
pattern1 | pattern2) comnands1;;
pattern3) commands2;;
*) default commands;;
esac

# 栗子
case $days in
3 | 4)
 echo "3"
 echo "4";;
5)
 echo "5";;
*)
 echo 0;;
esac
```


```bash
# 常见格式
${VARG} #引用变量
var1=$(command) #命令执行
count=$[1 + 2] #计算表达式
if [ condition ] #[]可以省略test condition


```
# linux shell

显示消息
echo -n ""  -n:不换行
echo $JAVA_HOME 或者 ${JAVA_HOME} 转义加上\

## 使用变量

查看环境变量
set

用户变量
days=10 没有空格，区分大小写

## 命令替换

```sh
today=`date`  # ``包围会把里面命令的输出赋值到左边
today=${date} # today=${date +%y%m%d}
```

## 重定向输入和输出

输出重定向
command > outputfile
command >> outputfile

输入重定向
command < inputfile
内联输入重定向
在命令行指定用于输入重定向的数据，但是需要marker用来划分输入数据的开始和结尾
command << marker  
data
marker
如  wc<<EOF
    > test string 1
    > test string 2
    > EOF 
    
管道
command1 | command2     

数学计算

expr 1 + 5
expr 1 \* 6
var1=$(expr $var2 / $var3)
等

![-w751](../blog_picture/2018-12-10-shell/15444263111526.jpg)


使用方括号, 通过美元符和方括号吧数学表达式围起来，可以把数据计算结果赋值给变量
var2=$[$var2 * 4]

浮点数方案
variable=$(echo "options; expression" | bc)
var1=$(echo "scale=4; 3.44/5" | bc)
通过内联重定向
variable=$(bc << EOF
options
statements
expressions
EOF
)

退出脚本

通过$?可以获取上次运行命令的exit状态码，为0~255的整数值，0表示命令成功结束
我们可以通过exit code返回exit状态码
exit 1 



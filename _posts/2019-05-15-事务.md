# ---
layout: post
title: 事务
categories: it
tags:  it 
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境

事务


# 事务
事务就是把多个读操作或者写操作当做一个逻辑单元，然后作为一个操作执行，执行结果可能是事务成功了(commit),或者失败了(rollback)

# ACID
#### Atomicity 
原子性: 如果多个操作作为一个事务执行，如果中途因为某种原因出错(不能committed)，事务需要中断，回滚在事务中已经执行的操作

提供的保障： 出错可以中断事务并抛弃事务所有执行的write。
![IMAGE](2019-05-15-transcation/6606DD6B6BF9955ACE9F684BFF28556D.jpg =689x248)

#### Consistency

一致性：数据在特定statements应该保持true。由应用保证该保障

#### Isolaton

隔离性：让并发执行的事务彼此隔离，不影响彼此。
![IMAGE](2019-05-15-transcation/2DC37E3A5C8FFF8BB1CD26574DB9DEB8.jpg =697x348)

#### Durability

持久性：一旦事务提交成功，数据就能保存下来，不会丢失。


> 并发问题(race condition)当一个事务读取一个数据(被其他事务并发修改)或者两个事务同时修改一个数据


# 隔离级别

## Read committed

### 定义
提供了两个保障
1. no dirty read 当读数据，只会读取到已经提交的数据
2. no dirty write 当写数据库，只会覆盖已经提交的数据。第二个写的事务必须等到第一个写的事务先提交，保证后者更新覆盖前者更新。

如果不提供不脏读，就有可能看到部分更新的数据，又或者看到后来事务出错会被回滚的数据。
![IMAGE](2019-05-15-transcation/3BF39FF628F36CEDEB78A18C77AF7FE2.jpg =687x279)
![IMAGE](2019-05-15-transcation/9DF4913EF8F2549DDD7C0B01E8435568.jpg =692x375)

> read committed并不能阻止race condition，两个交错的事务中写操作，第二个写操作会导致第一个写操作丢失(Lost update)

### 实现

为了防止脏写，需要到行级锁，当需要修改某个对象，首先需要获取这个对象的锁，然后保持这个锁知道事务提交或者中断。

为了防止脏读，数据库保留已经提交的旧值和正在被拥有锁的事务修改的新值，事务可以简单的读取已经提交的旧值，指导新值被提交上去。

## repeatable Read(snapshot isolation)

![IMAGE](2019-05-15-transcation/1F5F88BC7C1E2833BD9317950E9ABD70.jpg =681x345)
这种异常叫做不可重复读或者read skew

snapshot isolation可以解决这个问题。每个事务读取一个一致性快照(在事务开始看到所有已经提交的数据，卡在事务开始的时间点，后续的事务更新的数据都没法查看)，可用于备份。

### 实现

快照隔离的核心是读不阻塞写，写不阻塞读。这样子允许数据库在处理在一个一致性快照上长久读的查询，同时还可以处理正常写操作。数据库需要保持对象的不同提交版本，因为不同事务，需要看到数据库不同时间上的不同状态，这项技术也叫做Multi-version concurrency control(MVCC)
![IMAGE](2019-05-15-transcation/80CA09BFF6CCD5ABF33660EE905C8F4A.jpg =673x542)

## Preventing Lost Updates

更新丢失会发生在如果软件读取一个值，然后修改它，再会写它，如果两个事务同事做这个操作，其中一个修改就会丢失，因为后者修改没有包含前者的修改。

实现方案

#### 原子写操操作(Atomic write operations)
去掉应用代码中read-modify-write cycle。

```sql
UPDATE counters SET value = value + 1
WHERE key = 'foo';
```

原子操作实现方式：可以通过对象的排它锁组织其他事务读取该对象，直到完成更新；或者通过将所有原子操作都在单线程执行。  

#### 显示锁(Explict locking)

显示锁住需要更新的对象

```sql
BEGIN TRANSACTION;
SELECT * FROM figures
WHERE name = 'robot' AND game_id = 222 FOR UPDATE;

-- Check whether move is valid, then update the position
-- of the piece that was returned by the previous SELECT. UPDATE figures SET position = 'c4' WHERE id = 1234;
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```

> for update语句指示数据库应该锁住所有该查询语句返回的行。

#### Automatically detecting lost updates
事务管理器会检测lost update, 然后中断事务，强制重试read-modify-write周期。InnoDB不支持

#### Compare and Set

todo


write skew 写倾斜 
非lost updates, 作用于两个对象 医生值班的例子， 可以作为广义lost update
两个医生并行修改值班记录，会导致没医生值班，如果只要顺序操作，就不会写倾斜

模式：

1.输入匹配条件 select查询匹配的行
2.根据查询操作，然后报错，或者执行后续操作
3. 如果可以执行，则可以发起操作，更新插入删除，并提交事务。

这个写操作3，会影响2操作的判断，也就是说如果提交3操作后，执行1会不同的内容
如果查询1没有返回任何行，就没法采用for update锁住行
这种在另外一个事务的写入改变另外一个事务的查询结果的现象，就是幻读。快照级别可以解决只读查询的幻读，但是没法解决倾斜，


serialized

1 串行化：
  事务必须剪短高效
  数据能在内存里，否则读取磁盘IO拖累性能
  写入吞吐量必须低

2. 2阶段加锁
  读写操作互相排斥
  读取对象想要获取共享锁，多个事务可以获取同一个对象的共享锁，如果需要写，则需要申请独占锁，独占锁会跟其他锁排斥，如果已经共享锁或者独占锁在对象上，必须等待其释放
  获取锁之后，直到事务提交，才会释放，第一阶段事务提交之前获取锁，第二季阶段事务提交之后释放锁

  2.1 谓词锁 作用于满足某些查询条件的所有查询调剂，如会议室订房间，特定时间端某家房间
      如某个查询想获取满足某个匹配条件的，必须给以共享模式给匹配条件加上谓词锁
      保护那些还不存在但是可能会马上插入的数据(防止幻读
      
  2.2 索引区间锁 把谓词锁保护的对象放大，基于索引建立的锁，如果列不是索引，会变成锁表，也是防止写倾斜和幻读情况
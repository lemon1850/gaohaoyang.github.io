---
layout: post
title: JVM面试
categories: 面试
tags:  面试
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境

JVM
1、详细jvm内存模型
2、讲讲什么情况下回出现内存溢出，内存泄漏？
3、说说Java线程栈
4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？
6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？
7、类的实例化顺序
8、JVM垃圾回收机制，何时触发MinorGC等操作
9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的
10、各种回收器，各自优缺点，重点CMS、G1
11、各种回收算法
12、OOM错误，stackoverflow错误，permgen space错误




2.GC CMS，CMS的参数

33.JVM的一些排查工具jstat, jstack ,jmap

67 、out Of memory Error 跟 stack Over flow Error 的比较

JVM判断对象是否回收

<https://www.atatech.org/articles/116648>

永久代 元空间

<https://www.jianshu.com/p/c1ac5e7a5f87>

java JVM
极度推荐： https://rednaxelafx.iteye.com/

判断对象是否存活，我们一般通过以下的方法

1\. 引用计数算法

 当对象被引用，计数器值就加1，当引用失效，则计数器减1，当计数器值为0，对象则不能再被使用，缺点难以处理对象循环引用的问题

2\. 可达性分析算法

 从GC ROOTs对象作为起始点，从这些节点开始向下开始搜索（对象引用的对象），搜索所走的路径被引用为引用链Reference Chain，但一个对象没有与引用链相连，则认为不可用。
 ![IMAGE](quiver-image-url/B9C72564F79205D4D93CD8F676FB385E.jpg =547x384)
 GC ROOTs种类
  执行上下文：虚拟机栈中引用的对象
  全局引用：方法区类静态属性引用的对象，方法区中常量引用的对象？
  
引用分类
强引用(Strong Reference) 不会被垃圾回收器回收
软引用(Soft Referenece) 如果内存要溢出，才会回收这部分
弱引用(Weak Reference)  下次垃圾回收，无论内存够不够都会回收它
虚引用(Phantom Reference) 无法通过虚引用取到引用的对象实例，设置的目的就是这个对象被垃圾回收时收到一个系统通知。


回收方法区
回收废弃常量和无用的类
例如常量池字面量，字符串"tianhe", 如果没有地方引用它，则可以移除它。

垃圾回收算法
1. 标记-清除算法 mark-sweep
  容易碎片太多，分配较大对象，容易频发触发gc
2. 标记-整理算法 mark-compact
  适合存活率高的，适合老年代使用。
3. 复制算法 copying
    把内存划分成2块大小相等的内存，每次只使用其中一块，当一块用完了，把上面存活复制到另外一块上。适合存活率抵的，
hotspot虚拟机采用一个Eden区和两个Survivior区，大小比例8：1，10%内存浪费，如果存货对象超过10%，需要老年代分配担保，直接进入老年代
4. 分代收集算法
  根据对象的存活周期把内存划分几块，如新生代和老年代，根据各年代特点采取合适的收集算法。

hotspot算法
  枚举根节点 //todo完善
    可达性分析需要在一个一致的快照中中进行。就是在分析期间整个系统冻结在一个时间点，否则会出现分析过程中对象引用关系在不断变化，则会无法保证分析结果准确性。因此必须暂停所有java执行线程(stop the world)，
  完全点  
    那我们如何到达安全点呢，通过主动式中断，当GC需要中断线程，会设置一个标志，线程会主动轮询这个标志，发现标志位真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。
  安全区域
    但是如果线程阻塞或者sleep, 线程无法响应JVM中断请求，走到安全地方中断挂起，因此需要safe Region.如果一段代码区域之中，引用关系不会发生变化，那么这个区域任意地方开始GC都是安全的，这段区域叫做safe region。线程执行到safe Region代码中，会标记自己为Safe Region，GC的时候就可以放心不用等Safe Region的线程，但是线程离开Safe Region，必须等待系统完成根节点枚举。
  
    
    
引用 https://rednaxelafx.iteye.com/blog/1044951 //todo 补

保守式GC： JVM选择不记录这种类型的数据，无法区分内存中某个位置的数据到底是引用类型还是整型别的，GC时，JVM从已知位置(JVM栈)扫描内存，扫描一个数字看看像不像指向GC堆中的指针(涉及到上下界检查(GC堆的上下界已知)、对其检查（分配空有时会有字节对齐，如4字节对齐)

准确式GC 判断出所有活动位置上的数据是不是指向GC堆的引用
1. 数据自身带上tag
2. 从外部记录下类型信息，存成映射表，如OopMap, JIT编译后后方法会在特定位置上记录下OopMap（如果每个指令都生成OopMap,将会很大）,记录了执行到该方法的某条指令的时候，栈和寄存器那些位置是引用，GC在扫描时，查询这些OopMap就知道那些是引用，特定位置主要在1）循环末尾，2）方法返回前/调用方法的call指令后 3）可能抛异常的位置，这些长时间执行的位置叫做安全点(safepoint)

垃圾收集器
![IMAGE](quiver-image-url/527764EE4D461624717727C18CB54CA7.jpg =360x366)


关注吞吐量
Parallel Scavenge(复制)/Parallel Old(标记整理)
获取最短回收停顿时间，Parallel Scavenge通过最大停顿时间MaxGcPauseMills和设置吞吐量大小比例GCTimeRatio参数来精确控制吞吐量。

关注响应时间
ParNew/CMS

CMS（老年代 标记清除算法）
四个重要步骤
1.初始标记(stop the world) 标记GC Roots关联的对象
2.并发标记  GC Roots Tracing
3.重新标记(stop the world) 修正并发标记期间用户程序继续运行导致标记产生变动的那一部分对象的标记记录
4.并发清除

优缺点：
1.CPU资源敏感，如果CPU太少，加大CPU负载。
2.会产生浮动垃圾，因为并发清除阶段，用户线程还会执行，会不断产生垃圾，这些对象只能下次GC回收，因此，CMS需要在老年代预留空间，设置CMSIntiatingOccupancyFraction百分比，当高于这个比例就会开始GC，如果运行阶段内存不足，导致Concurrent Mode Failure则退化到Serial Old进行垃圾回收.
3. 标记-清除算法容易导致大量空间碎片, 可以配置进行碎片合并整理。

G1收集器

http://blog.jobbole.com/109170/
https://hllvm-group.iteye.com/group/topic/44381#post-272188 //todo


内存分配：
  新对象分配：一般先在Eden分配，不够空间，触发Minor GC, 如果对象无法放入Survivor空间，则分配担保机制转移到老年代
  大对象：配置PreentureSizeThreshold大小，大过这个大小的大对象，直接进入老年代
  长期存活的对象进入老年代：survivor区对象熬过特定次数Minor GC,会进入老年代
  动态对象年龄判定：survivor空间中相同年龄所有对象大小总和大于survivor空间一般，年龄大于或等于该年龄的对象直接进入老年代。
  空间分配担保： minor GC对象会晋升到survivor区，如果survivor区空间不够就到老年代，如果老年代空间不够，担保失败，则出现Full GC 
  


在cms算法中，young gc的实现过程？
先找出根对象，如Java栈中引用的对象、静态变量引用的对象和系统词典中引用的对象等待，把这些对象标记成活跃对象，并复制到to区，接着遍历这些活跃对象中引用的对象并标记，找出老年代对象在eden区有引用关系的对象并标记，最后把这些标记的对象复制到to，在复制过程还要判断活跃对象的gc年龄是否已经达到阈值，如果已经达到阈值，就直接晋升到老年代，YGC结束之后把from和to的引用互换。
其实这里又会遇到几个概念，最好的情况是，面试者可以自己说出来，比如:

promotion failed
concurrent mode failed

作者：占小狼
链接：https://www.jianshu.com/p/573b5c6b8e89
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。

---
layout: post
title: spring揭秘
categories: database db orm 框架
tags:  orm mybatis
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境

spring揭秘



# 


```java
public interface Pointcut {
    Pointcut TRUE = TruePointcut.INSTANCE;

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();
}

```

![-w674](../blog_picture/2019-11-02-spring_discover/15411435737933.jpg)



```java
public interface MethodInterceptor extends Interceptor {
    Object invoke(MethodInvocation var1) throws Throwable;
}
public interface MethodInvocation extends Invocation {
    Method getMethod();
}
public interface Invocation extends Joinpoint {
    Object[] getArguments();
}
public interface Joinpoint {
    Object proceed() throws Throwable;

    Object getThis();

    AccessibleObject getStaticPart();
}
public interface IntroductionInterceptor extends MethodInterceptor, DynamicIntroductionAdvice {
}
public interface DynamicIntroductionAdvice extends Advice {

	boolean implementsInterface(Class<?> intf);

}

public interface IntroductionAdvisor extends Advisor, IntroductionInfo {
    ClassFilter getClassFilter();

    void validateInterfaces() throws IllegalArgumentException;
}

```

![-w780](../blog_picture/2019-11-02-spring_discover/15517649199011.jpg)


![-w804](../blog_picture/2019-11-02-spring_discover/15415055642591.jpg)


![-w468](../blog_picture/2019-11-02-spring_discover/15415072862726.jpg)

![-w782](../blog_picture/2019-11-02-spring_discover/15415075470697.jpg)
![-w381](../blog_picture/2019-11-02-spring_discover/15415106593599.jpg)

![-w466](../blog_picture/2019-11-02-spring_discover/15517652624759.jpg)
![-w773](../blog_picture/2019-11-02-spring_discover/15517652694564.jpg)


![-w456](../blog_picture/2019-11-02-spring_discover/15517653971948.jpg)


![-w826](../blog_picture/2019-11-02-spring_discover/15517656440731.jpg)


![-w724](../blog_picture/2019-11-02-spring_discover/15517657600870.jpg)


![-w598](../blog_picture/2019-11-02-spring_discover/15517662907533.jpg)
![-w783](../blog_picture/2019-11-02-spring_discover/15517668707619.jpg)


![-w758](../blog_picture/2019-11-02-spring_discover/15517671083891.jpg)

## 事务

# 事务管理

db常见问题
    脏读
    不可重复读
    幻读

隔离级别
    未提交读
    提交读
    重复读
    串行
    ![-w881](../blog_picture/2019-11-02-spring_discover/15487567578832.jpg)

    
 多个Dao需要在一个事务中执行sql, 那么如何让Dao共享一个连接，然后把事务控制层和数据访问层都摆脱这个具体的具体的访问技术
 
 可以通过线程绑定一个Connection的方式，如通过ThreadLocal
 
 ![-w827](../blog_picture/2019-11-02-spring_discover/15487568946349.jpg)

    
```java
public interface PlatformTransactionManager {
    TransactionStatus getTransaction(TransactionDefinition var1) throws TransactionException;

    void commit(TransactionStatus var1) throws TransactionException;

    void rollback(TransactionStatus var1) throws TransactionException;
}
public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1; //无法避免脏读，不可以避免不可重复读和幻读
    int ISOLATION_READ_COMMITTED = 2;//避免脏读，不可以避免不可重复读和幻读
    int ISOLATION_REPEATABLE_READ = 4;//避免脏读，不可重复读，不可以避免幻读
    int ISOLATION_SERIALIZABLE = 8; //全都避免
    int TIMEOUT_DEFAULT = -1;

    int getPropagationBehavior();

    int getIsolationLevel();

    int getTimeout();

    boolean isReadOnly();

    String getName();
}
public interface TransactionStatus extends SavepointManager, Flushable {
    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();
}

DataSourceUtils 转义错误，管理数据源
TransactionSynchronizationManager 管理线程跟connection绑定关系
PlatformTransactionManager 事务边界，根据TransactionDefinition属性定义开启相关事务
TransactionDefinition 负责隔离级别和传播行为，超时时间，只读事务
TransactionStatus 事务开启之后到事务结束期间的事务状态管理
```


![-w563](../blog_picture/2019-11-02-spring_discover/15487577778655.jpg)

####  PROPAGATION_REQUIRED 
如果当前存在一个事务，则加入该事务，如果不存在任何事务，则创建一个新事务
#### PROPAGATION_SUPPORTS 
如果当前存在一个事务，则加入该事务，如果不存在任何事务，则直接执行。如果当前方法被其他方法(该方法开启了一个事务)调用，那么PROPAGATION_SUPPORTS可以使当前方法加入该事务，洞察当前事务对数据资源的做的更新
#### PROPAGATION_MANDATORY 
强制当前存在一个事务，如果不存在，则抛出异常。如果某个方法需要事务支持，但是自身又不管理事务回滚或者提交，那么适合用PROPAGATION_MANDATORY
#### PROPAGATION_REQUIRES_NEW 
不管当前是否存在事务，都会创建新的事务。如果当前存在事务，会降当前事务挂起。如果某个业务对象所做的事情不想影响到外层事务，适合使用PROPAGATION_REQUIRES_NEW。例如当前业务的方法需要向数据库中更新某些日志信息，即使这些日志信息更新失败，我们也不想因为该业务方法的事务回滚，而影响到外层事务的成功提交。
#### PROPAGATION_NOT_SUPPORTED 
不支持当前事务，而是在没有事务的情况下执行，如果当前存在事务的话，当前事务原则上会挂起
#### PROPAGATION_NEVER
永远不需要当前存在事务，如果存在事务，则抛出异常
#### PROPAGATION_NESTED
如果当前存在事务，则在当前事务的一个嵌套事务中执行，否则，创建新的事务。PROPAGATION_NESTED跟PROPAGATION_REQUIRES_NEW区别是，PROPAGATION_REQUIRES_NEW创建的新事务跟外层事务是同一个档次，两者地位相同的，当新创建的事务运行的时候，外层事务就会被暂时挂起，另外，内外层事务拥有各自独立的状态而互不干扰，而PROPAGATION_NESTED创建的嵌套事务则不然，寄托于当前外层事务，地位比外层事务低，当内部嵌套事务运行的时候，外层事务也是active，内部自是无处理内容属于当前外层事务的一部分，不能独立于外层事务而存在，并且与外层事务共有事务状态。

应用场景：把一个大事务划成多个小事务处理，并且外部事务可以根据各个内部嵌套事务的执行结果，来选择不同的执行流程。如
![-w341](../blog_picture/2019-11-02-spring_discover/15487613656825.jpg)




![-w703](../blog_picture/2019-11-02-spring_discover/15487605983823.jpg)
![-w765](../blog_picture/2019-11-02-spring_discover/15487608509668.jpg)


![-w808](../blog_picture/2019-11-02-spring_discover/15487630269322.jpg)


![-w481](../blog_picture/2019-11-02-spring_discover/15487636016724.jpg)


![-w871](../blog_picture/2019-11-02-spring_discover/15487652170056.jpg)

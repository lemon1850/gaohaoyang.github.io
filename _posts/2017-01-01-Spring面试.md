---
layout: post
title: 网络协议面试
categories: 面试
tags:  面试
---

* content
{:toc}

> 我的技术博客，主要是记载看过的书以及对写的好的博客文章的搬运整理，方便自己他人查看，也方便别人指出我文章中的错误，达到一起学习的目的。
> 技术永无止境




Spring

1、BeanFactory 和 FactoryBean？

 beanFactory是ioc容器，用来管理bean, 实例化和装配bean， factoryBean是一个特殊的可以生产和装饰对象的工厂bean, 调用getObject可以获取相应的bean, 有点类似工厂模式和装饰器模式(可以加上代理逻辑)，如果想获取工厂的bean实例，需要加上&

    public class AmqpProxyFactoryBean extends AmqpClientInterceptor implements FactoryBean<Object>, BeanClassLoaderAware, InitializingBean {
        private Object serviceProxy;

     public AmqpProxyFactoryBean() {
        }

        public void afterPropertiesSet() {
            if (this.getServiceInterface() == null) {
                throw new IllegalArgumentException("Property 'serviceInterface' is required");
     } else {
                this.serviceProxy = (new ProxyFactory(this.getServiceInterface(), this)).getProxy(this.getBeanClassLoader());
     }
        }

        public Object getObject() throws Exception {
            return this.serviceProxy;
     }

        public Class<?> getObjectType() {
            return this.getServiceInterface();
     }

        public boolean isSingleton() {
            return true;
     }
    }

2、Spring IOC 的理解，其初始化过程？

1.容器初始化：首先根据你配置资源xml，文件的加载，扫描解析成beanDefinition, 然后注册到Ioc容器

2.ioc容器注入：

![](2017-01-01-ready-spring/4C7CC297AAF2F81DE7EA3AC5EF367D92.jpg)

![](2017-01-01-ready-spring/B9B50B8A7942F64AAE9AA302949D34AE.jpg)

![](2017-01-01-ready-spring/74500C4398E5B848969FC6CA74458B73.jpg)

初始化 <https://www.zhihu.com/search?type=content&q=ioc%E5%88%9D%E5%A7%8B%E5%8C%96>

![](2017-01-01-ready-spring/5A142F69ADE044248FC6E118434F8353.jpg)

3、BeanFactory 和 ApplicationContext？

BeanFactory：这是IOC容器的接口定义，提供了IoC最基本的功能，如果说容器是个汽车工厂，那么这个结构就规定了汽车工厂最基本的功能，能储存零件，能组装汽车。只提供getBean()

**ApplicationContext**：升级版汽车厂，除了上面的功能，还提供很多人性化的服务，继承了 MessageSource，ResourceLoader，ApplicationEventPublisher等等接口，在BeanFactory 简单IoC容器的基础上添加了许多对高级容器的支持。

4、Spring Bean 的生命周期，如何被管理的？

 1、实例化一个Bean－－也就是我们常说的new；

 2、按照Spring上下文对实例化的Bean进行配置－－也就是IOC注入；

 3、如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring配置文件中Bean的id值

 4、如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(setBeanFactory(BeanFactory)传递的是Spring工厂自身（可以用这个方式来获取其它Bean，只需在Spring配置文件中配置一个普通的Bean就可以）；

 5、如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法）；

 6、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术；

 7、如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。

 8、如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法、；

 注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。

 9、当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法；

 10、最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。

![](2017-01-01-ready-spring/50010F68BD302AFD59A3524361F1D1F5.jpg)

5、Spring Bean 的加载过程是怎样的？

<https://zhuanlan.zhihu.com/p/34901871>

6、如果要你实现Spring AOP，请问怎么实现？

7、如果要你实现Spring IOC，你会注意哪些问题？

10、Spring 中用到了那些设计模式？

11、Spring MVC 的工作原理？

12、Spring 循环注入的原理？

循环依赖 <https://zhuanlan.zhihu.com/p/34923466>

setter可以采用循环依赖 构造器注入没法解决循环依赖

13、Spring AOP的理解，各个术语，他们是怎么相互工作的？

* JoinPoint
* PointCut
* Advice
* Target
* Aspect 由 PointCut 和 Advice 组成。

静态代理

 1\. 编译时编制 特殊编译器 2类加载时编制 特俗类加载器

 动态代理

 JDK动态代理

JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。

CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 `final` ，那么它是无法使用 CGLIB 做动态代理的

 CGLI动态代理

14、Spring 如何保证 Controller 并发的安全？

案是当然可以，只需要在类上添加注解@Scope("prototype")即可，这样每次请求调用的类都是重新生成的（每次生成会影响效率）

使用**ThreadLocal**来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来。

8、Spring 是如何管理事务的，事务管理机制？

[https://mp.weixin.qq.com/s?\_\_biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh\_CN\#rd](https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd)

* **PlatformTransactionManager：** （平台）事务管理器
* **TransactionDefinition：** 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
* **TransactionStatus：** 事务运行状态

  Public interface PlatformTransactionManager()...{
 // Return a currently active transaction or create a new one, according to the specified propagation behavior（根据指定的传播行为，返回当前活动的事务或创建一个新事务。）
 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
 // Commit the given transaction, with regard to its status（使用事务目前的状态提交事务）
 Void commit(TransactionStatus status) throws TransactionException;
 // Perform a rollback of the given transaction（对执行的事务进行回滚）
 Void rollback(TransactionStatus status) throws TransactionException;
 }

   \<!-- 事务管理器 --\>
 \<bean id="transactionManager"
 class="org.springframework.jdbc.datasource.DataSourceTransactionManager"\>
 \<!-- 数据源 --\>
 \<property name="dataSource" ref="dataSource" /\>
 \</bean\>

9、Spring 的不同事务传播行为有哪些，干什么用的？

**支持当前事务的情况：**

* **TransactionDefinition.PROPAGATION\_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
* **TransactionDefinition.PROPAGATION\_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
* **TransactionDefinition.PROPAGATION\_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。

**不支持当前事务的情况：**

* **TransactionDefinition.PROPAGATION\_REQUIRES\_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
* **TransactionDefinition.PROPAGATION\_NOT\_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
* **TransactionDefinition.PROPAGATION\_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

* **TransactionDefinition.PROPAGATION\_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION\_REQUIRED。

  public interface TransactionStatus{
 boolean isNewTransaction(); // 是否是新的事物
 boolean hasSavepoint(); // 是否有恢复点
 void setRollbackOnly(); // 设置为只回滚
 boolean isRollbackOnly(); // 是否为只回滚
 boolean isCompleted; // 是否已完成
}

spring扩展
FactroyBean
public interface FactoryBean<T> {
    T getObject() throws Exception;
    Class<?> getObjectType();
    boolean isSingleton();
}
 XML 方式的 AOP 就是通过该接口实现
 
 BeanPostProcess
 可以在初始化前和初始化之后对实例进行加工 注解配置的AOP是如何实现的。就是间接实现了该接口。在 IOC 初始化的时候，会调用的该接口的后置处理方法。
 public interface BeanPostProcessor {
    Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;

    Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;
}

实例化前后的处理  早于初始化
public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {
    Object postProcessBeforeInstantiation(Class<?> var1, String var2) throws BeansException;

    boolean postProcessAfterInstantiation(Object var1, String var2) throws BeansException;

    PropertyValues postProcessPropertyValues(PropertyValues var1, PropertyDescriptor[] var2, Object var3, String var4) throws BeansException;
}


public interface BeanFactoryPostProcessor {
    void postProcessBeanFactory(ConfigurableListableBeanFactory var1) throws BeansException;
}
Spring允许在Bean创建之前，读取Bean的元属性，并根据自己的需求对元属性进行改变，比如将Bean的scope从singleton改变为prototype
如pylon的特殊处理


 InitializingBean 在属性设置完毕后做一些自定义操作。 DisposableBean 在关闭容器前做一些操作。
 public interface InitializingBean {
    void afterPropertiesSet() throws Exception;
}
public interface DisposableBean {
    void destroy() throws Exception;
}

BeanNameAware、ApplicationContextAware 和 BeanFactoryAware 针对bean工厂，可以获取上下文，可以获取当前bean的id。

参考https://blog.csdn.net/qq_38182963/article/details/78795058










